<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Caja 3D (15 cm) ‚Äî Parallax + Eye Tracking + F√≠sica + UI (v4.1.3)</title>
  <style>
    :root{
      --bg:#06070c; --fg:#eaeef7; --muted:#90a3b6; --accent:#6dd3ff;
      --panel: rgba(10,12,20,.55); --panel-b: rgba(255,255,255,.12);
      --glow: 0 0 0 6px rgba(109,211,255,.12) inset;
    }
    html, body { height:100%; }
    body { margin:0; background: radial-gradient(1200px 900px at 20% -10%, #101323, transparent 60%), linear-gradient(180deg, #03040a, #06070c 40%, #03040a); color:var(--fg); font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial; }
    #app { position:fixed; inset:0; overflow:hidden; }
    #three { width:100%; height:100%; display:block; touch-action:none; }
    .bezel { position:fixed; inset:0; pointer-events:none; box-shadow: inset 0 0 0 12px rgba(0,0,0,.85), inset 0 0 32px rgba(0,0,0,.85), inset 0 0 120px rgba(0,0,0,.85); border-radius: 24px; }

    /* ======= UI ======= */
    .ui { position:fixed; left:0; right:0; bottom:0; padding:10px env(safe-area-inset-right) calc(10px + env(safe-area-inset-bottom)) env(safe-area-inset-left);
      display:flex; gap:8px; flex-wrap:wrap; align-items:center; justify-content:center; pointer-events:auto; transition: transform .35s ease, opacity .35s ease; }
    .ui.min { transform: translateY(85%); opacity:.15; }
    .panel { backdrop-filter: blur(14px) saturate(1.2); background: var(--panel); border:1px solid var(--panel-b);
      border-radius:16px; padding:10px 12px; display:flex; gap:10px; align-items:center; flex-wrap:wrap; }
    .btn, .seg, .slider { color:var(--fg); font-weight:600; letter-spacing:.2px; }
    .btn { border:1px solid var(--panel-b); background:linear-gradient(180deg, rgba(255,255,255,.08), rgba(255,255,255,.02)); border-radius:12px; padding:10px 12px; cursor:pointer; user-select:none; transition: transform .08s ease, box-shadow .2s ease; }
    .btn:active { transform: translateY(1px) scale(.99); }
    .btn[data-on="true"] { outline:1.6px solid var(--accent); box-shadow: var(--glow); }
    .seg { display:flex; border:1px solid var(--panel-b); border-radius:12px; overflow:hidden; }
    .seg button { all:unset; padding:10px 12px; cursor:pointer; background:rgba(255,255,255,.04); }
    .seg button[data-active="true"] { background:rgba(109,211,255,.18); color:white; }
    .field { display:flex; align-items:center; gap:8px; }
    .field label { font-size:12px; color:var(--muted); }
    .field input[type="range"] { width:120px; }

    #toast { position:fixed; top:10px; left:0; right:0; margin:auto; width:max(260px, 90vw); text-align:center; pointer-events:none; }
    #toast .msg { display:inline-block; padding:10px 14px; border-radius:12px; background:rgba(15,18,30,.85); border:1px solid rgba(255,255,255,.12); }

    #stats { position:fixed; top:0; right:0; padding:8px 10px; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace; font-size:12px; opacity:.85; }

    #webcam { position:fixed; right:8px; top:8px; width:200px; height:auto; transform:scaleX(-1); border-radius:10px; border:1px solid rgba(255,255,255,.12); display:none; }
    #debug { position:fixed; right:8px; top:8px; width:200px; height:auto; display:none; pointer-events:none; }

    /* Mini dock */
    #miniDock { position:fixed; right:10px; bottom:10px; display:flex; gap:8px; align-items:center; }
    #miniDock .bubble { border:1px solid var(--panel-b); background:var(--panel); border-radius:999px; padding:10px; cursor:pointer; backdrop-filter: blur(14px) saturate(1.2); }

    /* Onboarding / Indicaciones */
    #onboarding { position:fixed; inset:0; display:grid; place-items:center; background: radial-gradient(1200px 900px at center, rgba(8,11,18,.7), rgba(8,11,18,.3) 40%, rgba(0,0,0,.1)); pointer-events:auto; z-index: 10; }
    #onboarding .card { max-width: min(560px, 90vw); border-radius:16px; border:1px solid var(--panel-b); background:var(--panel); padding:20px; }
    #onboarding h2 { margin:0 0 6px 0; font-size:20px; }
    #onboarding p { margin:0 0 14px 0; color:var(--muted); line-height:1.35; }
    #onboarding .row { display:flex; gap:10px; align-items:center; }
    #onboarding .meter { width:100%; height:8px; border-radius:999px; background:rgba(255,255,255,.08); overflow:hidden; }
    #onboarding .meter .bar { height:8px; width:0%; background:linear-gradient(90deg, var(--accent), #9bf3ff); transition: width .2s ease; }
    #onboarding .actions { display:flex; gap:10px; justify-content:flex-end; margin-top:12px; }

    /* Accessibilidad */
    @media (prefers-reduced-motion: reduce) {
      .btn { transition: none; }
      .ui { transition: none; }
    }
  </style>
</head>
<body>
  <div id="app">
    <canvas id="three"></canvas>
    <div class="bezel" aria-hidden="true"></div>
  </div>

  <!-- ======= UI ======= -->
  <div class="ui" id="ui">
    <div class="panel">
      <div class="seg" id="inputMode">
        <button data-mode="camera">C√°mara</button>
        <button data-mode="gyro">Giroscopio</button>
        <button data-mode="mouse">Mouse</button>
      </div>
      <div class="seg" id="quality">
        <button data-q="perf">Perf</button>
        <button data-q="bal">Bal</button>
        <button data-q="ultra">Ultra</button>
      </div>
      <div class="seg" id="object">
        <button data-k="pyr">Pyr</button>
        <button data-k="cube">Cube</button>
        <button data-k="ico">Ico</button>
        <button data-k="ball">Bola</button>
        <button data-k="torus">Torus</button>
      </div>

      <div class="seg" id="theme">
        <button data-t="neon">Ne√≥n</button>
        <button data-t="sunset">Sunset</button>
        <button data-t="matrix">Matrix</button>
      </div>

      <button class="btn" id="toggleDebug">Debug</button>
      <button class="btn" id="calibrate">Calibrar</button>
      <button class="btn" id="toggleShadows">Sombras</button>
      <button class="btn" id="toggleBloom">Bloom</button>
      <button class="btn" id="toggleParticles">Part√≠culas</button>
      <button class="btn" id="togglePhysics">F√≠sica</button>
      <button class="btn" id="toggleGrid">Grid</button>
      <button class="btn" id="mirrorX">Mirror X</button>
      <button class="btn" id="invertY">Invert Y</button>
      <button class="btn" id="reset">Reset</button>
      <button class="btn" id="shot">üì∑</button>
      <button class="btn" id="fullscreen">‚õ∂</button>

      <div class="field slider">
        <label for="screenW">Ancho pantalla (cm)</label>
        <input id="screenW" type="range" min="5" max="9" step="0.1" value="7" />
        <span id="screenWVal">7.0</span>
      </div>
      <div class="field slider">
        <label for="dist">Distancia (cm)</label>
        <input id="dist" type="range" min="20" max="80" step="1" value="40" />
        <span id="distVal">40</span>
      </div>
      <div class="field slider">
        <label for="depth">Profundidad caja (cm)</label>
        <input id="depth" type="range" min="5" max="20" step="0.5" value="15" />
        <span id="depthVal">15</span>
      </div>
      <div class="field slider">
        <label for="smoothing">Suavizado</label>
        <input id="smoothing" type="range" min="0" max="0.6" step="0.02" value="0.18" />
        <span id="smoothingVal">0.18</span>
      </div>
      <div class="field slider">
        <label for="exposure">Exposici√≥n</label>
        <input id="exposure" type="range" min="0.5" max="2.0" step="0.01" value="1.0" />
        <span id="exposureVal">1.00</span>
      </div>
      <div class="field slider">
        <label for="bloomStrength">Bloom</label>
        <input id="bloomStrength" type="range" min="0.0" max="2.0" step="0.01" value="0.6" />
        <span id="bloomStrengthVal">0.60</span>
      </div>
    </div>
  </div>

  <!-- Mini dock: minimizar UI y acceso r√°pido -->
  <div id="miniDock">
    <div class="bubble" id="toggleUI" title="Mostrar/Ocultar UI">ü°±</div>
  </div>

  <!-- Onboarding / indicaciones iniciales -->
  <div id="onboarding" hidden>
    <div class="card">
      <h2>Preparaci√≥n r√°pida</h2>
      <p>Deja el tel√©fono apoyado en una superficie <b>horizontal</b> y estable. Luego toca <b>Listo</b>. Si usas mouse o webcam, puedes continuar igualmente.</p>
      <div class="row">
        <div class="meter" aria-label="nivel de inclinaci√≥n">
          <div class="bar" id="tiltBar" style="width:0%"></div>
        </div>
        <span id="tiltPct" style="width:56px; text-align:right; color:var(--muted)">0%</span>
      </div>
      <div class="actions">
        <button class="btn" id="skipOnboarding">Saltar</button>
        <button class="btn" id="confirmOnboarding">Listo</button>
      </div>
    </div>
  </div>

  <div id="toast"></div>
  <div id="stats"></div>
  <video id="webcam" autoplay playsinline muted></video>
  <canvas id="debug"></canvas>

  <!-- Polyfill de import maps -->
  <script async crossorigin="anonymous" src="https://ga.jspm.io/npm:es-module-shims@1.8.0/dist/es-module-shims.js"></script>

  <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
    }
  }
  </script>

  <script type="module">
    import * as THREE from 'three';
    import { RoomEnvironment } from 'three/addons/environments/RoomEnvironment.js';
    import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
    import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
    import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
    import { OutputPass } from 'three/addons/postprocessing/OutputPass.js';

    const need = (id) => { const el = document.getElementById(id); if (!el) throw new Error('Falta #' + id); return el; };
    const clamp = (v,lo,hi)=>Math.min(hi, Math.max(lo,v));

    if (document.readyState === 'loading') document.addEventListener('DOMContentLoaded', main);
    else main();

    function ensureContainer(){
      let app = need('app');
      if(!app){ app = document.createElement('div'); app.id='app'; app.style.position='fixed'; app.style.inset='0'; app.style.overflow='hidden'; document.body.appendChild(app); }
      let canvas = need('three');
      if(!canvas){ canvas = document.createElement('canvas'); canvas.id='three'; app.prepend(canvas); }
      let bezel = document.querySelector('.bezel');
      if(!bezel){ bezel = document.createElement('div'); bezel.className='bezel'; app.appendChild(bezel); }
      return { app, canvas };
    }

    function main(){
      const { canvas } = ensureContainer();

      // ===== Estado + persistencia =====
      const save = ()=>localStorage.setItem('holoBox:v41', JSON.stringify(stateToPersist()));
      const load = ()=>{ try{ return JSON.parse(localStorage.getItem('holoBox:v41')||'{}'); }catch{ return {} } };
      const defaults = {
        mode:'camera', quality:'bal', object:'pyr', theme:'neon',
        shadowsOn:false, gridOn:false, mirror:false, bloomOn:false,
        particlesOn:true, physicsOn:true, invertY:true,
        screenW:7.0, dist:40, depth:15, smoothing:0.18, exposure:1.0, bloomStrength:0.6,
        uiMin:false, seenOnboarding:false
      };
      const state = Object.assign({}, defaults, load());

      // ===== Renderer / Escena / C√°mara =====
      const renderer = new THREE.WebGLRenderer({ canvas, antialias:true, alpha:false, powerPreference:'high-performance' });
      renderer.outputColorSpace = THREE.SRGBColorSpace;
      renderer.physicallyCorrectLights = true;
      renderer.toneMapping = THREE.ACESFilmicToneMapping;
      let targetDPR = Math.min(devicePixelRatio, 2);
      renderer.setPixelRatio(targetDPR);
      renderer.setSize(innerWidth, innerHeight);

      const scene = new THREE.Scene();
      scene.background = new THREE.Color(0x05060a);

      const pmrem = new THREE.PMREMGenerator(renderer);
      const env = new RoomEnvironment(renderer);
      const envTex = pmrem.fromScene(env, 0.04).texture;
      scene.environment = envTex;

      const near = 0.01, far = 2.5;
      const camera = new THREE.PerspectiveCamera(50, innerWidth/innerHeight, near, far);
      camera.position.set(0, 0, 0.4);

      // ===== Helpers de render/Composer (colocados temprano) =====
      let composer, bloomPass;
      const sizeVec = new THREE.Vector2();
      let lastW = innerWidth, lastH = innerHeight, lastDPR = targetDPR;
      function ensureComposer(){
        if(!composer){
          composer = new EffectComposer(renderer);
          composer.setSize(innerWidth, innerHeight);
          const renderPass = new RenderPass(scene, camera);
          bloomPass = new UnrealBloomPass(new THREE.Vector2(innerWidth, innerHeight), parseFloat(need('bloomStrength').value), 0.4, 0.85);
          const out = new OutputPass();
          composer.addPass(renderPass); composer.addPass(bloomPass); composer.addPass(out);
        }
      }
      function ensureRenderSize(force=false){
        if(innerWidth === 0 || innerHeight === 0) return;
        renderer.getSize(sizeVec);
        const needResize = force || sizeVec.x !== innerWidth || sizeVec.y !== innerHeight || lastDPR !== targetDPR;
        if(needResize){
          renderer.setPixelRatio(targetDPR);
          renderer.setSize(innerWidth, innerHeight, false);
          camera.aspect = innerWidth/innerHeight;
          camera.updateProjectionMatrix();
          if(composer) composer.setSize(innerWidth, innerHeight);
          lastW = innerWidth; lastH = innerHeight; lastDPR = targetDPR;
        }
      }

      // ===== Derivados de estado =====
      let screenW_cm = +state.screenW;
      const screen = { w: screenW_cm/100, h: (screenW_cm/100) * (innerHeight/innerWidth) };
      let boxDepth_cm = +state.depth;
      let currentObject = state.object;
      let mirror = !!state.mirror;
      let invertY = !!state.invertY;
      let physicsOn = !!state.physicsOn;
      let particlesOn = !!state.particlesOn;
      let theme = state.theme || 'neon';

      function updateScreenMeters(){
        screen.w = (screenW_cm/100);
        screen.h = screen.w * (innerHeight/innerWidth);
        if(grid) { grid.scale.set(screen.w*0.98, 1, screen.h*0.98); }
        if(boardGroup) { fitBoard(); }
      }

      function makePerspectiveOffCenter(cam, left, right, bottom, top, near, far){
        const x = 2*near/(right-left), y = 2*near/(top-bottom), a = (right+left)/(right-left), b = (top+bottom)/(top-bottom), c = -(far+near)/(far-near), d = -2*far*near/(far-near);
        cam.projectionMatrix.set(x,0,a,0, 0,y,b,0, 0,0,c,d, 0,0,-1,0);
      }

      // ===== Iluminaci√≥n =====
      const hemi = new THREE.HemisphereLight(0x99bbff, 0x101318, 0.6); scene.add(hemi);
      const key = new THREE.SpotLight(0x9cc9ff, 1.1, 3.0, Math.PI/6, 0.35, 1.0); key.position.set(0.25,0.22, 0.25); scene.add(key);
      const rim = new THREE.DirectionalLight(0xffffff, 0.45); rim.position.set(-0.3,-0.4,-0.2); scene.add(rim);
      const fill = new THREE.PointLight(0x66eeff, 0.35, 1.0); fill.position.set(-0.12, 0.15, -0.25); scene.add(fill);

      // ===== Objetos de escena =====
      const group = new THREE.Group(); scene.add(group);
      let obj, floor, walls, grid, boardGroup, boardMesh, edgeMesh, neonStrips=[];

      function themedColors(t){
        if(t==='sunset') return { wall:0x0a0a10, floor:0x1c0f11, hemiSky:0xffd8a8, hemiGnd:0x180b0a, key:0xff9b73, rim:0xffd0a8, fill:0xff6b6b, accent:0xffa94d };
        if(t==='matrix') return { wall:0x050807, floor:0x0a0f0a, hemiSky:0xa6ffc3, hemiGnd:0x0b0f0b, key:0x7dffb3, rim:0xa6ffc3, fill:0x00ffa3, accent:0x00ff88 };
        return { wall:0x0b0c10, floor:0x0d1117, hemiSky:0x99bbff, hemiGnd:0x101318, key:0x9cc9ff, rim:0xffffff, fill:0x66eeff, accent:0x6dd3ff };
      }

      function applyTheme(t){
        theme = t;
        const c = themedColors(t);
        hemi.color.setHex(c.hemiSky);
        hemi.groundColor.setHex(c.hemiGnd);
        key.color.setHex(c.key);
        rim.color.setHex(c.rim);
        fill.color.setHex(c.fill);
        if(walls) walls.material.color.setHex(c.wall);
        if(floor) floor.material.color.setHex(c.floor);
        neonStrips.forEach(m=>m.material.emissive.setHex(c.accent));
        document.documentElement.style.setProperty('--accent', '#' + new THREE.Color(c.accent).getHexString());
      }

      function buildObject(kind, w, h, d){
        currentObject = kind;
        let mesh;
        const accent = themedColors(theme).accent;
        if(kind==='cube'){
          const geo = new THREE.BoxGeometry(Math.min(w,h)*0.28, Math.min(w,h)*0.28, Math.min(w,h)*0.28);
          const mat = new THREE.MeshPhysicalMaterial({ color:0xffffff, roughness:0.07, transmission:1.0, thickness:0.03, ior:1.5, clearcoat:1, clearcoatRoughness:0.08, attenuationColor:new THREE.Color(accent), attenuationDistance:2.0 });
          mesh = new THREE.Mesh(geo, mat);
        } else if(kind==='ico'){
          const geo = new THREE.IcosahedronGeometry(Math.min(w,h)*0.18, 1);
          const mat = new THREE.MeshPhysicalMaterial({ color:0xffffff, roughness:0.06, transmission:1.0, thickness:0.025, ior:1.5, clearcoat:1, clearcoatRoughness:0.08, attenuationColor:new THREE.Color(accent), attenuationDistance:2.0 });
          mesh = new THREE.Mesh(geo, mat);
        } else if(kind==='torus'){
          const geo = new THREE.TorusKnotGeometry(Math.min(w,h)*0.12, Math.min(w,h)*0.035, 140, 18);
          const mat = new THREE.MeshPhysicalMaterial({ color:new THREE.Color(accent), roughness:0.25, metalness:0.85, clearcoat:1, clearcoatRoughness:0.1 });
          mesh = new THREE.Mesh(geo, mat);
        } else if(kind==='ball'){
          const r = Math.min(w,h)*0.05;
          const geo = new THREE.SphereGeometry(r, 48, 32);
          const mat = new THREE.MeshPhysicalMaterial({ color:0xffffff, roughness:0.2, metalness:0.0, clearcoat:1, clearcoatRoughness:0.1, transmission:0.2, ior:1.3, attenuationColor:new THREE.Color(accent), attenuationDistance:3.0, envMapIntensity:1.2 });
          mesh = new THREE.Mesh(geo, mat);
          mesh.userData.radius = r;
        } else {
          const pyrH = Math.min(d*0.66, h*0.6), pyrR = Math.min(w,h)*0.16;
          const geo = new THREE.ConeGeometry(pyrR, pyrH, 4, 1, false); geo.rotateY(Math.PI/4);
          const mat = new THREE.MeshPhysicalMaterial({ color:0xffffff, roughness:0.06, transmission:1.0, thickness:0.02, ior:1.5, envMapIntensity:1.2, attenuationColor:new THREE.Color(accent), attenuationDistance:2.0, reflectivity:0.1, clearcoat:1.0, clearcoatRoughness:0.08 });
          mesh = new THREE.Mesh(geo, mat);
        }
        mesh.position.set(0, 0, -(boxDepth_cm/100)*0.50);
        mesh.castShadow = true;
        return mesh;
      }

      function addNeonStrips(w, h, d){
        neonStrips.forEach(s=>group.remove(s));
        neonStrips.length = 0;
        const accent = themedColors(theme).accent;
        const stripGeo = new THREE.BoxGeometry(0.002, 0.002, Math.min(w,h)*0.35);
        const mat = new THREE.MeshStandardMaterial({ color:0xffffff, emissive:new THREE.Color(accent), emissiveIntensity:1.2, metalness:0.2, roughness:0.4 });
        const s1 = new THREE.Mesh(stripGeo, mat); s1.position.set(-w*0.36,  h*0.25, -d*0.65); s1.rotateY(Math.PI*0.1);
        const s2 = new THREE.Mesh(stripGeo, mat); s2.position.set( w*0.38, -h*0.22, -d*0.35); s2.rotateY(-Math.PI*0.1);
        neonStrips.push(s1, s2); neonStrips.forEach(s=>{ s.castShadow = false; group.add(s); });
      }

      function applyShadows(on){
        renderer.shadowMap.enabled = on;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        key.castShadow = on; rim.castShadow = on; hemi.castShadow = false; fill.castShadow = on;
        if(obj) obj.castShadow = on;
        if(floor) floor.receiveShadow = on;
        if(boardMesh) boardMesh.receiveShadow = on;
        if(edgeMesh) edgeMesh.castShadow = on;
      }

      // ===== Piso/box + tablero de juego =====
      function makeBox(){
        group.clear();
        const depth = boxDepth_cm/100; const w = screen.w, h = screen.h, d = depth;

        const wallMat = new THREE.MeshPhysicalMaterial({ color:0x0b0c10, roughness:0.9, metalness:0.0, side:THREE.BackSide, clearcoat:0.2, clearcoatRoughness:0.7 });
        const boxGeo = new THREE.BoxGeometry(w, h, d);
        walls = new THREE.Mesh(boxGeo, wallMat); walls.position.set(0,0,-d/2); group.add(walls);

        const floorMat = new THREE.MeshPhysicalMaterial({ color:0x0d1117, roughness:0.6, metalness:0.2, reflectivity:0.4 });
        floor = new THREE.Mesh(new THREE.PlaneGeometry(w*0.98, d*0.98), floorMat);
        floor.rotation.x=-Math.PI/2; floor.position.set(0,-h/2+0.001,-d/2); group.add(floor);

        grid = new THREE.GridHelper(Math.max(w,h), 24, 0x334455, 0x223344); grid.material.opacity=0.25; grid.material.transparent=true; grid.position.set(0,-h/2+0.0021,-d/2); grid.visible = !!state.gridOn; group.add(grid);

        obj = buildObject(currentObject, w, h, d); group.add(obj);
        addNeonStrips(w, h, d);
        makeBoard(); // tablero para f√≠sica de la esfera

        key.position.set(w*0.3, h*0.35, 0.25); key.target = obj; rim.position.set(-w*0.5, -h*0.6, -d*0.4);

        applyShadows(!!state.shadowsOn);
        applyTheme(theme);
        if(particlesOn) ensureParticles(); else removeParticles();
      }

      // ===== Tablero y bola =====
      function makeBoard(){
        if(boardGroup){ group.remove(boardGroup); boardGroup = null; }
        boardGroup = new THREE.Group(); group.add(boardGroup);
        const w = screen.w, h = screen.h, d = boxDepth_cm/100;
        const bw = w*0.78, bd = Math.min(d*0.7, h*0.65);
        const boardMat = new THREE.MeshPhysicalMaterial({ color:0x111623, metalness:0.15, roughness:0.38, clearcoat:0.3, clearcoatRoughness:0.3 });
        boardMesh = new THREE.Mesh(new THREE.PlaneGeometry(bw, bd, 1, 1), boardMat);
        boardMesh.rotation.x=-Math.PI/2;
        boardMesh.position.set(0, -h/2+0.005, -d*0.52);
        boardGroup.add(boardMesh);

        // Edges
        const edgeH = Math.min(h*0.06, 0.03);
        const edgeGeo = new THREE.BoxGeometry(bw, edgeH, 0.01);
        const edgeMat = new THREE.MeshStandardMaterial({ color:0x0b0f18, metalness:0.4, roughness:0.55 });
        const e1 = new THREE.Mesh(edgeGeo, edgeMat); e1.position.set(0, -h/2+edgeH/2, boardMesh.position.z - bd/2);
        const e2 = e1.clone(); e2.position.z = boardMesh.position.z + bd/2;
        const e3 = new THREE.Mesh(new THREE.BoxGeometry(0.01, edgeH, bd), edgeMat); e3.position.set(-bw/2, -h/2+edgeH/2, boardMesh.position.z);
        const e4 = e3.clone(); e4.position.x = bw/2;
        edgeMesh = new THREE.Group(); edgeMesh.add(e1,e2,e3,e4); boardGroup.add(edgeMesh);

        // Bola si corresponde
        if(currentObject==='ball'){
          const r = Math.min(w,h)*0.05;
          if(!obj || !obj.userData.radius){ obj = buildObject('ball', w,h,d); boardGroup.add(obj); }
          obj.position.set(0, (-h/2)+r+0.006, boardMesh.position.z);
          ballState.pos.set(0, obj.position.y, obj.position.z);
          ballState.vel.set(0,0,0);
          ballState.radius = r;
          boardGroup.add(obj);
        }
      }

      function fitBoard(){
        if(!boardGroup) return;
        const w = screen.w, h = screen.h, d = boxDepth_cm/100;
        const bw = w*0.78, bd = Math.min(d*0.7, h*0.65);
        boardMesh.geometry.dispose(); boardMesh.geometry = new THREE.PlaneGeometry(bw, bd, 1, 1);
        boardMesh.position.set(0, -h/2+0.005, -d*0.52);
        const edgeH = Math.min(h*0.06, 0.03);
        const children = edgeMesh.children;
        children[0].geometry.dispose(); children[0].geometry = new THREE.BoxGeometry(bw, edgeH, 0.01);
        children[0].position.set(0, -h/2+edgeH/2, boardMesh.position.z - bd/2);
        children[1].geometry.dispose(); children[1].geometry = new THREE.BoxGeometry(bw, edgeH, 0.01);
        children[1].position.set(0, -h/2+edgeH/2, boardMesh.position.z + bd/2);
        children[2].geometry.dispose(); children[2].geometry = new THREE.BoxGeometry(0.01, edgeH, bd);
        children[2].position.set(-bw/2, -h/2+edgeH/2, boardMesh.position.z);
        children[3].geometry.dispose(); children[3].geometry = new THREE.BoxGeometry(0.01, edgeH, bd);
        children[3].position.set(bw/2, -h/2+edgeH/2, boardMesh.position.z);
        if(currentObject==='ball' && obj){
          const r = Math.min(w,h)*0.05;
          obj.userData.radius = r;
          obj.position.set(obj.position.x, (-h/2)+r+0.006, obj.position.z);
          ballState.pos.y = obj.position.y;
          ballState.radius = r;
        }
      }

      // ===== Part√≠culas =====
      let particles;
      function ensureParticles(){
        removeParticles();
        const count = 180;
        const g = new THREE.BufferGeometry();
        const positions = new Float32Array(count*3);
        for(let i=0;i<count;i++){
          positions[i*3+0] = (Math.random()-0.5) * screen.w*0.9;
          positions[i*3+1] = (Math.random()-0.5) * screen.h*0.9;
          positions[i*3+2] = - (Math.random()) * (boxDepth_cm/100) * 0.95;
        }
        g.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        const m = new THREE.PointsMaterial({ size:0.002, color:0xffffff, transparent:true, opacity:0.7, depthWrite:false });
        particles = new THREE.Points(g, m);
        group.add(particles);
      }
      function removeParticles(){ if(particles){ group.remove(particles); particles.geometry.dispose(); particles.material.dispose(); particles=null; } }

      // ===== UI & Estado aplicado =====
      const uiRoot = need('ui');
      if(state.uiMin) uiRoot.classList.add('min');
      // Botones
      const btnDebug = need('toggleDebug');
      const btnCal = need('calibrate');
      const btnShadows=need('toggleShadows');
      const btnBloom=need('toggleBloom');
      const btnGrid=need('toggleGrid');
      const btnMirror=need('mirrorX');
      const btnInvertY=need('invertY');
      const btnReset=need('reset');
      const btnShot=need('shot');
      const btnFS=need('fullscreen');
      const btnUI=need('toggleUI');
      const btnParticles = need('toggleParticles');
      const btnPhysics = need('togglePhysics');
      // Sliders/valores
      const rExposure = need('exposure'), vExposure = need('exposureVal');
      const rBloom = need('bloomStrength'), vBloom = need('bloomStrengthVal');
      const rScreen = need('screenW'), rDist = need('dist'), rDepth = need('depth'), rSmooth = need('smoothing');
      const vScreen = need('screenWVal'), vDist = need('distVal'), vDepth = need('depthVal'), vSmooth = need('smoothingVal');

      // Estados iniciales
      rScreen.value = state.screenW; vScreen.textContent = (+rScreen.value).toFixed(1);
      rDist.value = state.dist; vDist.textContent = rDist.value;
      rDepth.value = state.depth; vDepth.textContent = rDepth.value;
      rSmooth.value = state.smoothing; vSmooth.textContent = rSmooth.value;
      rExposure.value = state.exposure; vExposure.textContent = (+rExposure.value).toFixed(2); renderer.toneMappingExposure = +rExposure.value;
      rBloom.value = state.bloomStrength; vBloom.textContent = (+rBloom.value).toFixed(2);
      btnShadows.dataset.on = state.shadowsOn; btnGrid.dataset.on = state.gridOn; btnBloom.dataset.on = state.bloomOn; btnMirror.dataset.on = mirror;
      btnParticles.dataset.on = particlesOn; btnPhysics.dataset.on = physicsOn; btnInvertY.dataset.on = invertY;

      // Toast: declarar temprano
      let toastT = null;
      function toast(txt, warn=false){
        const el = need('toast');
        el.innerHTML = `<span class="msg" style="border-color:${warn?'rgba(255,107,107,.3)':'rgba(109,211,255,.3)'}">${txt}</span>`;
        clearTimeout(toastT); toastT = setTimeout(()=> el.innerHTML='', 2400);
      }

      updateScreenMeters();
      makeBox();

      function stateToPersist(){
        return {
          mode: state.mode,
          quality: state.quality,
          object: currentObject,
          theme,
          shadowsOn: (btnShadows.dataset.on === 'true'),
          gridOn: (btnGrid.dataset.on === 'true'),
          mirror: mirror,
          invertY: (btnInvertY.dataset.on === 'true'),
          bloomOn: (btnBloom.dataset.on === 'true'),
          particlesOn: (btnParticles.dataset.on === 'true'),
          physicsOn: (btnPhysics.dataset.on === 'true'),
          screenW: +rScreen.value,
          dist: +rDist.value,
          depth: +rDepth.value,
          smoothing: +rSmooth.value,
          exposure: +rExposure.value,
          bloomStrength: +rBloom.value,
          uiMin: uiRoot.classList.contains('min'),
          seenOnboarding: state.seenOnboarding
        };
      }

      // ===== Entradas (ojo/parallax + tilt para f√≠sica) =====
      const eye = { x:0, y:0, z: (+state.dist)/100 }, targetEye = { x:0, y:0, z: (+state.dist)/100 };
      let smooth = +state.smoothing;

      const tilt = { x:0, y:0 }; // -1..1 aprox
      function updateTiltFromEye(){
        const rx = screen.w*0.35, ry = screen.h*0.35;
        tilt.x = clamp(targetEye.x / rx, -1, 1);
        const ty = (invertY ? -targetEye.y : targetEye.y);
        tilt.y = clamp(ty / ry, -1, 1);
      }

      let lastGamma=0, lastBeta=0;
      function enableGyro(){
        function handler(ev){
          const g = (ev.gamma||0), b=(ev.beta||0);
          lastGamma = g; lastBeta = b;
          targetEye.x = clamp((g/30) * (screen.w*0.15), -screen.w*0.2, screen.w*0.2);
          const by = (b/45);
          const mappedY = (invertY ? -by : by) * (screen.h*0.15);
          targetEye.y = clamp(mappedY, -screen.h*0.2, screen.h*0.2);
          // tilt para f√≠sica (signo coherente con invertY)
          tilt.x = clamp(g/30, -1, 1);
          tilt.y = clamp((invertY ? -by : by), -1, 1);
        }
        if (typeof DeviceMotionEvent !== 'undefined' && typeof DeviceMotionEvent.requestPermission === 'function'){
          DeviceMotionEvent.requestPermission().then(st=>{
            if(st==='granted'){ addEventListener('deviceorientation', handler); toast('Giroscopio activo'); }
            else toast('Permiso de giroscopio denegado', true);
          }).catch(()=>toast('Giroscopio no disponible', true));
        } else {
          addEventListener('deviceorientation', handler); toast('Giroscopio activo');
        }
      }

      function enableMouse(){
        function onMove(e){
          const nx=(e.clientX/innerWidth)*2-1, ny=(e.clientY/innerHeight)*2-1;
          targetEye.x=clamp(nx*screen.w*0.25, -screen.w*0.3, screen.w*0.3);
          const my = (invertY ? -ny : ny);
          targetEye.y=clamp(my*screen.h*0.25, -screen.h*0.3, screen.h*0.3);
          updateTiltFromEye();
        }
        addEventListener('mousemove', onMove); toast('Parallax por mouse activo');
      }

      let faceTrackEnabled=false; const faceBridge = { ready:false, cx:0.5, cy:0.5, ipd:0.06 };
      window.__setFace = (cx, cy, ipd)=>{ faceBridge.ready = true; faceBridge.cx = cx; faceBridge.cy = cy; faceBridge.ipd = ipd; };

      async function enableCamera(){
        const v = need('webcam');
        try {
          const stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode:'user', width:{ideal:640}, height:{ideal:480} }, audio:false });
          v.srcObject = stream; await v.play(); faceTrackEnabled = true; toast('C√°mara activa (tracking de ojos)');
        } catch(e){ toast('No se pudo acceder a la c√°mara', true); }
      }

      function setMode(mode){
        state.mode = mode; save();
        const [camBtn, gyroBtn, mouseBtn] = need('inputMode').querySelectorAll('button');
        camBtn.dataset.active = (mode==='camera'); gyroBtn.dataset.active = (mode==='gyro'); mouseBtn.dataset.active = (mode==='mouse');
        if(mode==='camera') enableCamera();
        else if(mode==='gyro') enableGyro();
        else if(mode==='mouse') enableMouse();
      }
      need('inputMode').onclick = (e)=>{ const b=e.target.closest('button'); if(!b) return; setMode(b.dataset.mode); };
      setMode(state.mode);

      function applyQuality(q){
        state.quality = q; save();
        need('quality').querySelectorAll('button').forEach(b=>b.dataset.active = (b.dataset.q===q));
        if(q==='perf'){ targetDPR = Math.min(1.0, devicePixelRatio); applyShadows(false); btnBloom.dataset.on=false; }
        else if(q==='bal'){ targetDPR = Math.min(1.5, devicePixelRatio); }
        else { targetDPR = Math.min(2.0, devicePixelRatio); }
        ensureRenderSize(true);
      }
      need('quality').onclick = (e)=>{ const b=e.target.closest('button'); if(!b) return; applyQuality(b.dataset.q); };
      applyQuality(state.quality);

      function setObject(k){ currentObject = k; document.querySelectorAll('#object button').forEach(b=>b.dataset.active = (b.dataset.k===k)); makeBox(); save(); }
      need('object').onclick = (e)=>{ const b=e.target.closest('button'); if(!b) return; setObject(b.dataset.k); };
      setObject(state.object);

      need('theme').onclick = (e)=>{ const b=e.target.closest('button'); if(!b) return; document.querySelectorAll('#theme button').forEach(bb=>bb.dataset.active = (bb.dataset.t===b.dataset.t)); applyTheme(b.dataset.t); save(); };
      document.querySelectorAll('#theme button').forEach(bb=>bb.dataset.active = (bb.dataset.t===theme)); applyTheme(theme);

      // ===== Handlers =====
      btnDebug.onclick = ()=>{ const on = !(btnDebug.dataset.on==='true'); btnDebug.dataset.on = on; need('webcam').style.display = on? 'block':'none'; need('debug').style.display = on? 'block':'none'; };
      btnShadows.onclick = ()=>{ const on = !(btnShadows.dataset.on==='true'); btnShadows.dataset.on = on; applyShadows(on); save(); };
      btnBloom.onclick = ()=>{ const on = !(btnBloom.dataset.on==='true'); btnBloom.dataset.on = on; if(on) ensureComposer(); save(); };
      btnGrid.onclick = ()=>{ if(grid){ grid.visible = !grid.visible; btnGrid.dataset.on = grid.visible; save(); } };
      btnParticles.onclick = ()=>{ particlesOn = !particlesOn; btnParticles.dataset.on = particlesOn; if(particlesOn) ensureParticles(); else removeParticles(); save(); }
      btnPhysics.onclick = ()=>{ physicsOn = !physicsOn; btnPhysics.dataset.on = physicsOn; save(); }
      btnMirror.onclick = ()=>{ mirror = !mirror; btnMirror.dataset.on = mirror; save(); };
      btnInvertY.onclick = ()=>{ invertY = !invertY; btnInvertY.dataset.on = invertY; updateTiltFromEye(); save(); };
      btnCal.onclick = ()=>{ targetEye.x=0; targetEye.y=0; eye.x=0; eye.y=0; toast('Calibrado'); save(); };
      btnReset.onclick = ()=>{ localStorage.removeItem('holoBox:v41'); location.reload(); };
      btnShot.onclick = ()=>{ try{ const url = renderer.domElement.toDataURL('image/png'); const a=document.createElement('a'); a.href=url; a.download='holoBox_v41.png'; a.click(); }catch(e){ toast('No se pudo capturar', true);} };
      btnFS.onclick = async ()=>{
        try{
          if(!document.fullscreenElement){ await document.documentElement.requestFullscreen({navigationUI:'hide'}); } else { await document.exitFullscreen(); }
        }catch(e){ toast('No se pudo cambiar a pantalla completa', true); }
      };
      btnUI.onclick = ()=>{ uiRoot.classList.toggle('min'); save(); };

      rScreen.oninput = ()=>{ screenW_cm = +rScreen.value; vScreen.textContent = (+rScreen.value).toFixed(1); updateScreenMeters(); makeBox(); save(); };
      rDist.oninput = ()=>{ targetEye.z = (+rDist.value)/100; vDist.textContent = rDist.value; save(); };
      rDepth.oninput = ()=>{ boxDepth_cm = +rDepth.value; vDepth.textContent = rDepth.value; makeBox(); save(); };
      rSmooth.oninput = ()=>{ smooth = +rSmooth.value; vSmooth.textContent = rSmooth.value; save(); };
      rExposure.oninput = ()=>{ renderer.toneMappingExposure = +rExposure.value; vExposure.textContent = (+rExposure.value).toFixed(2); save(); };
      rBloom.oninput = ()=>{ vBloom.textContent = (+rBloom.value).toFixed(2); if(bloomPass) bloomPass.strength = parseFloat(rBloom.value); save(); };

      // ===== Interacciones micro =====
      const raycaster = new THREE.Raycaster();
      const clickPt = new THREE.Vector2();
      function onCanvasClick(e){
        clickPt.x = (e.clientX/innerWidth)*2 - 1;
        clickPt.y = -(e.clientY/innerHeight)*2 + 1;
        raycaster.setFromCamera(clickPt, camera);
        const hits = raycaster.intersectObjects([obj, boardMesh, ...neonStrips].filter(Boolean), true);
        if(hits.length){
          const p = hits[0].point;
          if(currentObject==='ball' && physicsOn){
            const dir = new THREE.Vector3().subVectors(obj.position, p).setY(0).normalize();
            ballState.vel.addScaledVector(dir, 0.25);
          } else if(obj){
            obj.scale.set(1.02,1.02,1.02);
            setTimeout(()=>obj.scale.set(1,1,1), 120);
            obj.rotation.y += 0.2;
          }
        }
      }
      canvas.addEventListener('click', onCanvasClick);

      // ===== F√≠sica simple para la bola =====
      const ballState = {
        pos: new THREE.Vector3(),
        vel: new THREE.Vector3(),
        radius: 0.02
      };
      function stepBall(dt){
        if(!physicsOn) return;
        if(currentObject!=='ball' || !obj || !boardMesh) return;
        const w = screen.w, h = screen.h, d = boxDepth_cm/100;
        const bw = w*0.78, bd = Math.min(d*0.7, h*0.65);
        const boardY = -h/2 + ballState.radius + 0.006;
        const boardZ = boardMesh.position.z;

        const g = 1.2;
        const ax = tilt.x * g;
        const az = tilt.y * g; // ya viene invertido si corresponde

        ballState.vel.x += ax * dt;
        ballState.vel.z += az * dt;

        const fr = Math.pow(0.985, dt*60);
        ballState.vel.multiplyScalar(fr);
        if(ballState.vel.length() < 0.001) ballState.vel.set(0,0,0);

        ballState.pos.x += ballState.vel.x * dt;
        ballState.pos.z += ballState.vel.z * dt;

        const maxX = bw/2 - ballState.radius*1.02;
        const maxZ = bd/2 - ballState.radius*1.02;
        if(ballState.pos.x < -maxX){ ballState.pos.x = -maxX; ballState.vel.x *= -0.55; microShake(); }
        if(ballState.pos.x >  maxX){ ballState.pos.x =  maxX; ballState.vel.x *= -0.55; microShake(); }
        if(ballState.pos.z < (-maxZ)+boardZ){ ballState.pos.z = (-maxZ)+boardZ; ballState.vel.z *= -0.55; microShake(); }
        if(ballState.pos.z >  (maxZ)+boardZ){ ballState.pos.z =  (maxZ)+boardZ; ballState.vel.z *= -0.55; microShake(); }

        obj.position.set(ballState.pos.x, boardY, ballState.pos.z);

        const v = new THREE.Vector3(ballState.vel.x, 0, ballState.vel.z);
        const speed = v.length();
        if(speed > 1e-4){
          const axis = new THREE.Vector3(-v.z, 0, v.x).normalize();
          const angle = (speed * dt) / ballState.radius;
          obj.rotateOnWorldAxis(axis, angle);
        }
      }
      function microShake(){ camera.position.z += 0.002; }

      // ===== Proyecci√≥n de c√°mara =====
      function updateCameraProjection(){
        const halfW = screen.w/2, halfH = screen.h/2; const n=near, f=far;
        const z = Math.max(0.05, eye.z);
        const left   = n * (-halfW - eye.x) / z;
        const right  = n * ( halfW - eye.x) / z;
        const bottom = n * (-halfH - eye.y) / z;
        const top    = n * ( halfH - eye.y) / z;
        makePerspectiveOffCenter(camera, left, right, bottom, top, n, f);
        camera.position.set(eye.x, eye.y, eye.z); camera.lookAt(eye.x, eye.y, 0);
      }

      // ===== Loop =====
      let tPrev = performance.now(), fpsAvg = 60, neonT=0, statsAccum=0;
      function frame(t){
        const dt = Math.min(0.05, (t - tPrev) / 1000); tPrev = t;

        if(faceTrackEnabled && faceBridge.ready){
          const cx = faceBridge.cx, cy = faceBridge.cy;
          const flipX = mirror ? -1 : 1;
          const x = (0.5*flipX - cx*flipX) * screen.w;
          // Invertir y si corresponde
          const yRaw = (cy - 0.5) * screen.h;
          const y = invertY ? -yRaw : yRaw;
          targetEye.x = clamp(x, -screen.w*0.35, screen.w*0.35);
          targetEye.y = clamp(y, -screen.h*0.35, screen.h*0.35);
          const ipdN = faceBridge.ipd; if(ipdN>0){ const F=0.45; const est=Math.min(0.8, Math.max(0.25, (0.063/Math.max(0.02,ipdN))*F)); targetEye.z = 0.5*targetEye.z + 0.5*est; }
          updateTiltFromEye();
        }

        const sp = Math.hypot(targetEye.x-eye.x, targetEye.y-eye.y, (targetEye.z-eye.z)*0.7);
        const sDyn = Math.min(0.6, Math.max(0.02, smooth - sp*0.25));
        const k = 1.0 - Math.pow(1.0 - sDyn, dt*60);
        eye.x += (targetEye.x - eye.x)*k;
        eye.y += (targetEye.y - eye.y)*k;
        eye.z += (targetEye.z - eye.z)*k;

        updateCameraProjection();
        stepBall(dt);

        if(particles){ neonT += dt; const o = 0.6 + Math.sin(neonT*2.0)*0.1; particles.material.opacity = o; }

        const fps = 1/dt; fpsAvg = fpsAvg + (fps - fpsAvg)*0.05;
        if(fpsAvg < 30 && targetDPR > 0.8){ targetDPR = Math.max(0.7, targetDPR - 0.05); ensureRenderSize(); }
        else if(fpsAvg > 58){
          const cap = (state.quality==='perf'?1:state.quality==='bal'?1.5:2);
          if(targetDPR < Math.min(cap, devicePixelRatio)){ targetDPR = Math.min(Math.min(cap, devicePixelRatio), targetDPR + 0.03); ensureRenderSize(); }
        }

        ensureRenderSize();

        if(btnBloom.dataset.on==='true' && composer){
          if(innerWidth>0 && innerHeight>0){ composer.render(); }
        } else {
          renderer.render(scene, camera);
        }

        statsAccum += dt;
        if(statsAccum > 0.25){
          need('stats').textContent = `eye: ${(eye.x*100).toFixed(1)}cm, ${(eye.y*100).toFixed(1)}cm, ${(eye.z*100).toFixed(0)}cm | screen: ${screenW_cm.toFixed(1)}cm √ó ${(screen.h*100).toFixed(1)}cm | dpr:${targetDPR.toFixed(2)} fps:${fpsAvg.toFixed(0)} | tilt: ${tilt.x.toFixed(2)}, ${tilt.y.toFixed(2)} | invertY:${invertY?'on':'off'}`;
          statsAccum = 0;
        }

        requestAnimationFrame(frame);
      }
      requestAnimationFrame(frame);

      addEventListener('resize', ()=>{ updateScreenMeters(); makeBox(); ensureRenderSize(true); });
      document.addEventListener('visibilitychange', ()=>{
        if(document.hidden){ targetDPR = Math.min(targetDPR, 1.0); ensureRenderSize(true); }
      });

      // ===== Onboarding =====
      const onboarding = need('onboarding');
      const tiltBar = need('tiltBar'), tiltPct = need('tiltPct');
      const confirmBtn = need('confirmOnboarding'), skipBtn = need('skipOnboarding');
      let stableTimer = 0;
      if(!state.seenOnboarding){ onboarding.hidden = false; }
      // Hacer que SIEMPRE se pueda cerrar
      function closeOnboarding(){
        try{ onboarding.remove(); }catch{ onboarding.hidden = true; }
        state.seenOnboarding = true; save(); toast('¬°Vamos!');
      }
      skipBtn.onclick = closeOnboarding;
      confirmBtn.onclick = closeOnboarding;
      // medidor (solo informativo)
      setInterval(()=>{
        const norm = Math.min(1, (Math.abs(lastGamma)/5 + Math.abs(lastBeta)/5)/2);
        const pct = Math.round((1-norm)*100);
        tiltBar.style.width = pct + '%'; tiltPct.textContent = pct + '%';
        if(pct > 85){ stableTimer += 200; } else { stableTimer = 0; }
      }, 200);

      // ===== Atajos =====
      addEventListener('keydown', (e)=>{
        if(e.key==='h') uiRoot.classList.toggle('min');
        if(e.key==='f') btnFS.click();
        if(e.key==='p') btnPhysics.click();
        if(e.key==='g') btnGrid.click();
        if(e.key==='b') btnBloom.click();
        if(e.key==='s') btnShadows.click();
        save();
      });

      window._three = { THREE, renderer, scene, camera, group };
    }
  </script>

  <!-- MediaPipe para eyes/iris -->
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js"></script>
  <script>
    (function(){
      const video = document.getElementById('webcam');
      const debug = document.getElementById('debug');
      const ctx = debug.getContext('2d');
      const faceMesh = new FaceMesh({locateFile: (file)=> `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`});
      faceMesh.setOptions({ maxNumFaces: 1, refineLandmarks: true, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });

      let FACE_FPS = 24, lastFaceTS = 0;
      faceMesh.onResults(onResults);
      let cam = null;

      async function start(){
        try{
          cam = new Camera(video, {
            onFrame: async () => {
              if (video.readyState < 2 || video.videoWidth === 0 || video.videoHeight === 0) return;
              const now = performance.now();
              if (now - lastFaceTS < (1000/FACE_FPS)) return;
              lastFaceTS = now;
              await faceMesh.send({image: video});
            },
            width: 640, height: 480
          });
          cam.start();
        } catch(e){ console.warn(e); }
      }
      start();

      function onResults(res){
        if(!res.multiFaceLandmarks || !res.multiFaceLandmarks.length || !res.image){ return; }
        const landmarks = res.multiFaceLandmarks[0];
        const L = [468,469,470,471], R = [473,474,475,476];
        const lc = centroid(L.map(i=>landmarks[i])); const rc = centroid(R.map(i=>landmarks[i]));
        const cx = (lc.x + rc.x)/2, cy = (lc.y + rc.y)/2; const ipd = Math.hypot(lc.x-rc.x, lc.y-rc.y);
        if(window.__setFace) window.__setFace(cx, cy, ipd);
        if(debug.style.display !== 'none'){
          const w = res.image.width || 640, h = res.image.height || 480;
          if(w>0 && h>0){
            debug.width = w; debug.height = h;
            ctx.save(); ctx.translate(debug.width,0); ctx.scale(-1,1);
            ctx.drawImage(res.image, 0, 0, debug.width, debug.height);
            drawIris(lc, rc);
            ctx.restore();
          }
        }
      }
      function drawIris(lc, rc){ ctx.lineWidth = 2; ctx.strokeStyle = 'rgba(0,255,255,.9)'; ctx.fillStyle = 'rgba(0,255,255,.25)'; [lc, rc].forEach(p=>{ ctx.beginPath(); ctx.arc(p.x*debug.width, p.y*debug.height, 8, 0, Math.PI*2); ctx.fill(); ctx.stroke(); }); ctx.beginPath(); ctx.moveTo(lc.x*debug.width, lc.y*debug.height); ctx.lineTo(rc.x*debug.width, rc.y*debug.height); ctx.stroke(); }
      function centroid(arr){ const n = arr.length; let x=0,y=0; for(const p of arr){ x+=p.x; y+=p.y; } return {x:x/n, y:y/n}; }

      document.addEventListener('visibilitychange', ()=>{
        try{
          if(document.hidden){ if(cam && cam.stop) cam.stop(); }
          else { if(cam && cam.start) cam.start(); }
        }catch(e){/* noop */}
      });
    })();
  </script>
</body>
</html>
